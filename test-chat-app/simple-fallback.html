<!doctype html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Skipify SDK Simple Fallback Test</title>
        <style>
            body {
                margin: 0;
                overflow: auto;
                font-family: Arial, sans-serif;
                padding: 20px;
                background-color: #f5f5f5;
            }
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }
            .test-section {
                margin: 20px 0;
                padding: 20px;
                border: 1px solid #ddd;
                border-radius: 5px;
            }
            button {
                padding: 10px 20px;
                background: #007bff;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                margin: 5px;
            }
            button:hover {
                background: #0056b3;
            }
            .result {
                margin: 10px 0;
                padding: 10px;
                border-radius: 5px;
                background: #f8f9fa;
                border: 1px solid #ddd;
            }
            .error {
                background: #f8d7da;
                border-color: #f5c6cb;
                color: #721c24;
            }
            .success {
                background: #d4edda;
                border-color: #c3e6cb;
                color: #155724;
            }
            input {
                width: 300px;
                padding: 8px;
                margin: 5px;
                border: 1px solid #ddd;
                border-radius: 3px;
            }
        </style>
        <!-- Simple fingerprinting mock to prevent timeouts -->
        <script type="text/javascript">
            // Provide fake fingerprint data to prevent timeouts
            console.log('Setting up fingerprinting mock...');
            
            // Mock FingerprintJS to prevent timeouts
            window.FingerprintJS = {
                load: () => Promise.resolve({
                    get: () => Promise.resolve({
                        visitorId: 'mock-fingerprint-id-' + Date.now(),
                        confidence: { score: 0.99 },
                        components: {
                            canvas: { value: 'mock-canvas-data' },
                            fonts: { value: ['mock-font-1', 'mock-font-2'] },
                            audio: { value: 'mock-audio-data' }
                        }
                    })
                })
            };
        </script>
        <!-- Fix postMessage origin mismatch by intercepting calls -->
        <script>
            // Intercept and fix postMessage calls before SDK loads
            console.log('üîß Setting up postMessage origin fix...');
            
            // Store original postMessage method
            const originalPostMessage = window.postMessage;
            
            // Override postMessage for all windows/iframes
            const originalWindowPostMessage = Window.prototype.postMessage;
            Window.prototype.postMessage = function(message, targetOrigin, transfer) {
                // If trying to send to staging.skipify.com, redirect to localhost
                if (targetOrigin === 'https://checkout.staging.skipify.com') {
                    console.log('üîß Redirecting postMessage from staging.skipify.com to localhost:8080');
                    console.log('üì® Original message:', message);
                    targetOrigin = window.location.origin; // http://localhost:8080
                }
                
                console.log('üì§ PostMessage call:', { message: message, targetOrigin: targetOrigin });
                return originalWindowPostMessage.call(this, message, targetOrigin, transfer);
            };
            
            console.log('‚úÖ postMessage origin fix installed');
        </script>
        
        <!-- Load Skipify SDK using static script tag -->
        <script src="https://stagecdn.skipify.com/sdk/components-sdk.js"></script>
    </head>

    <body>
        <div class="container">
            <h1>üöÄ Skipify SDK Simple Fallback Test</h1>
            <p>This page uses a static script tag to load the SDK (should avoid CORS issues).</p>
            
            <!-- Add container for Skipify iframes (required for embedded components) -->
            <div id="skipify-iframe-container" style="display: none;"></div>
            
            <div class="test-section">
                <h3>SDK Initialization Test</h3>
                <button onclick="testInitialization()">Test SDK Load</button>
                <div id="initResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>SDK Methods Test</h3>
                <button onclick="testMethods()">Test Available Methods</button>
                <div id="methodsResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Device ID Test</h3>
                <button onclick="testDeviceId()">Get Device ID</button>
                <div id="deviceIdResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Quick Operation Tests</h3>
                <button onclick="testAllBasicOperations()">Test All Basic Operations</button>
                <div id="basicOpsResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Simple Lookup Test</h3>
                <input type="email" id="testEmail" placeholder="Enter email for lookup test" value="nick.suess@skipify.com">
                <button onclick="testSimpleLookup()">Test Simple Lookup</button>
                <button onclick="testWorkingLookup()">‚úÖ Working Lookup (Fast)</button>
                <div id="lookupResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Network Monitoring Test</h3>
                <button onclick="testNetworkMonitoring()">Monitor Network Activity</button>
                <div id="networkResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Deep SDK Inspection</h3>
                <button onclick="testDeepInspection()">Inspect SDK Internals</button>
                <div id="inspectionResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Alternative Lookup Test</h3>
                <button onclick="testAlternativeLookup()">Test Alternative Lookup</button>
                <div id="alternativeLookupResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Targeted Lookup Test</h3>
                <button onclick="testTargetedLookup()">Test Targeted Lookup</button>
                <div id="targetedLookupResult" class="result"></div>
            </div>
            
            <div class="test-section">
                <h3>Iframe Status Test</h3>
                <button onclick="testIframeStatus()">Check Iframe Status</button>
                <div id="iframeStatusResult" class="result"></div>
            </div>
        </div>
    </body>
    
    <script type="text/javascript">
        let skipifySDK = null;

        // Initialize SDK when page loads
        window.addEventListener('load', function() {
            console.log('Page loaded, checking for SDK...');
            console.log('Window.skipify:', window.skipify);
            console.log('Window object keys:', Object.keys(window).filter(key => key.toLowerCase().includes('skipify')));
            
            if (window.skipify) {
                try {
                    // Use the exact same configuration as the working simple-test.html
                    const config = {
                        merchantId: '1bdc8b60-6dd4-4126-88e1-c9e5b570f1a0',
                        environment: 'stage',
                        // Add origin configuration to fix postMessage origin mismatch
                        origin: window.location.origin, // This should be 'http://localhost:8080'
                        parentOrigin: window.location.origin,
                        allowedOrigins: [window.location.origin, 'https://checkout.staging.skipify.com']
                    };
                    
                    console.log('Initializing SDK with config:', config);
                    skipifySDK = new window.skipify(config);
                    
                    console.log('SDK initialized:', skipifySDK);
                    console.log('SDK constructor name:', skipifySDK.constructor.name);
                    console.log('SDK prototype methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(skipifySDK)));
                    console.log('SDK instance properties:', Object.keys(skipifySDK));
                    
                    // Check for specific methods
                    const methodsToCheck = ['start', 'lookup', 'getDeviceId', 'authentication', 'carousel'];
                    methodsToCheck.forEach(method => {
                        console.log(`SDK.${method}:`, typeof skipifySDK[method]);
                    });
                    
                    showResult('initResult', '‚úÖ SDK loaded and initialized successfully', 'success');
                    
                } catch (error) {
                    console.error('SDK initialization error:', error);
                    console.error('Error stack:', error.stack);
                    showResult('initResult', `‚ùå SDK initialization failed: ${error.message}`, 'error');
                }
            } else {
                console.error('Skipify SDK not found on window object');
                showResult('initResult', '‚ùå Skipify SDK not found on window object', 'error');
            }
        });

        function testInitialization() {
            if (skipifySDK) {
                showResult('initResult', '‚úÖ SDK is initialized and ready', 'success');
            } else {
                showResult('initResult', '‚ùå SDK is not initialized', 'error');
            }
        }

        function testMethods() {
            if (!skipifySDK) {
                showResult('methodsResult', '‚ùå SDK not initialized', 'error');
                return;
            }

            const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(skipifySDK));
            const properties = Object.keys(skipifySDK);
            
            const result = `
                <strong>Available Methods:</strong><br>
                ${methods.join(', ')}<br><br>
                <strong>Instance Properties:</strong><br>
                ${properties.join(', ')}<br><br>
                <strong>Key Methods Check:</strong><br>
                ‚Ä¢ start(): ${typeof skipifySDK.start === 'function' ? '‚úÖ' : '‚ùå'}<br>
                ‚Ä¢ lookup(): ${typeof skipifySDK.lookup === 'function' ? '‚úÖ' : '‚ùå'}<br>
                ‚Ä¢ getDeviceId(): ${typeof skipifySDK.getDeviceId === 'function' ? '‚úÖ' : '‚ùå'}<br>
                ‚Ä¢ authentication(): ${typeof skipifySDK.authentication === 'function' ? '‚úÖ' : '‚ùå'}<br>
                ‚Ä¢ carousel(): ${typeof skipifySDK.carousel === 'function' ? '‚úÖ' : '‚ùå'}
            `;
            
            showResult('methodsResult', result, 'success');
        }

        async function testDeviceId() {
            if (!skipifySDK) {
                showResult('deviceIdResult', '‚ùå SDK not initialized', 'error');
                return;
            }

            try {
                showResult('deviceIdResult', 'üîÑ Getting device ID...', 'success');
                
                // Start SDK if needed
                if (typeof skipifySDK.start === 'function') {
                    skipifySDK.start();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                const deviceId = await skipifySDK.getDeviceId();
                showResult('deviceIdResult', `‚úÖ Device ID: ${deviceId}`, 'success');
                
            } catch (error) {
                console.error('Device ID error:', error);
                showResult('deviceIdResult', `‚ùå Device ID failed: ${error.message}`, 'error');
            }
        }

        async function testAllBasicOperations() {
            if (!skipifySDK) {
                showResult('basicOpsResult', '‚ùå SDK not initialized', 'error');
                return;
            }

            showResult('basicOpsResult', 'üîÑ Testing all basic operations...', 'success');
            let results = [];

            try {
                // Test 1: Device ID (should work)
                console.log('üß™ Testing getDeviceId...');
                const deviceId = await skipifySDK.getDeviceId();
                results.push(`‚úÖ getDeviceId(): ${deviceId}`);
            } catch (error) {
                results.push(`‚ùå getDeviceId(): ${error.message}`);
            }

            try {
                // Test 2: Simple lookup (minimal params)
                console.log('üß™ Testing lookup with minimal params...');
                const lookupResult = await Promise.race([
                    skipifySDK.lookup({ email: 'test@example.com' }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout after 3 seconds')), 3000))
                ]);
                results.push(`‚úÖ lookup(): ${JSON.stringify(lookupResult).substring(0, 100)}...`);
            } catch (error) {
                results.push(`‚ùå lookup(): ${error.message}`);
            }

            try {
                // Test 3: Check for other methods
                console.log('üß™ Testing other available methods...');
                const methods = ['start', 'authentication', 'carousel'];
                methods.forEach(method => {
                    if (typeof skipifySDK[method] === 'function') {
                        results.push(`üìã ${method}(): Available (function)`);
                    } else {
                        results.push(`‚ùå ${method}(): Not available`);
                    }
                });
            } catch (error) {
                results.push(`‚ùå Methods check: ${error.message}`);
            }

            const summary = `
                <strong>üß™ Basic Operations Test Results:</strong><br><br>
                ${results.join('<br>')}
            `;
            
            showResult('basicOpsResult', summary, 'success');
            console.log('üß™ Basic operations test completed:', results);
        }

        async function testWorkingLookup() {
            console.log('üéØ testWorkingLookup() function called - COPYING EXACT BASIC OPS APPROACH');
            
            if (!skipifySDK) {
                showResult('lookupResult', '‚ùå SDK not initialized', 'error');
                return;
            }

            const email = document.getElementById('testEmail').value || 'nick.suess@skipify.com';
            showResult('lookupResult', 'üîÑ Using EXACT basic operations approach...', 'success');
            
            try {
                // EXACT COPY from testAllBasicOperations that ALWAYS works
                console.log('üß™ Testing lookup with minimal params...');
                const lookupResult = await Promise.race([
                    skipifySDK.lookup({ email: email }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout after 3 seconds')), 3000))
                ]);
                
                console.log('‚úÖ BASIC OPS STYLE lookup completed successfully:', lookupResult);
                
                // EXACT SAME result handling as basic operations test
                const result = `‚úÖ lookup(): ${JSON.stringify(lookupResult).substring(0, 100)}...`;
                console.log('üìã Basic ops style result:', result);
                
                // Format nicely for display
                const formattedResult = `
                    <strong>‚úÖ Lookup Successful (Basic Ops Style)!</strong><br><br>
                    <strong>üìß Email:</strong> ${email}<br>
                    <strong>üîë Challenge ID:</strong> ${lookupResult.challengeId || 'Not provided'}<br><br>
                    <strong>üìù Full Response:</strong><br>
                    <pre>${JSON.stringify(lookupResult, null, 2)}</pre>
                    <br><strong>‚úÖ This uses the EXACT same code as "Test All Basic Operations" that always works!</strong>
                `;
                
                showResult('lookupResult', formattedResult, 'success');
                
            } catch (error) {
                // EXACT SAME error handling as basic operations test
                console.error('‚ùå Basic ops style lookup error:', error);
                const errorResult = `‚ùå lookup(): ${error.message}`;
                
                showResult('lookupResult', `
                    <strong>‚ùå Lookup Failed (Basic Ops Style)</strong><br><br>
                    <strong>Error:</strong> ${error.message}<br><br>
                    <strong>üí° Suggestion:</strong> Try clicking "Test All Basic Operations" instead - that one always works!<br>
                    Or wait a moment and try this button again.
                `, 'error');
            }
        }

        async function testSimpleLookup() {
            console.log('üîç testSimpleLookup() function called');
            
            if (!skipifySDK) {
                console.log('‚ùå SDK not initialized');
                showResult('lookupResult', '‚ùå SDK not initialized', 'error');
                return;
            }
            console.log('‚úÖ SDK is initialized:', skipifySDK);

            const email = document.getElementById('testEmail').value;
            console.log('üìß Email from input field:', email);
            
            if (!email) {
                console.log('‚ùå No email provided');
                showResult('lookupResult', '‚ùå Please enter an email address', 'error');
                return;
            }

            // Start network monitoring (declare outside try block for catch access)
            let networkRequests = [];
            const originalFetch = window.fetch;
            let messageHandler = null;
            let observer = null;

            try {
                showResult('lookupResult', 'üîÑ Performing simple lookup...', 'success');
                console.log('Starting lookup process for email:', email);
                window.fetch = function(...args) {
                    console.log('üåê Network request detected:', args[0]);
                    networkRequests.push({ type: 'fetch', url: args[0], timestamp: new Date() });
                    return originalFetch.apply(this, args);
                };
                
                // Start SDK if needed
                if (typeof skipifySDK.start === 'function') {
                    console.log('üöÄ Calling SDK.start()...');
                    const startResult = skipifySDK.start();
                    console.log('SDK.start() result:', startResult);
                    console.log('SDK.start() completed - about to wait 2 seconds...');
                    
                    console.log('‚è≥ Starting 2-second wait...');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    console.log('‚úÖ Waited 2 seconds after SDK.start() - continuing...');
                } else {
                    console.log('‚ö†Ô∏è SDK.start() method not available');
                }
                
                // Use the correct object format that we discovered works
                const lookupParams = { email: email };
                console.log('About to call SDK.lookup() with:', lookupParams);
                console.log('SDK object before lookup:', skipifySDK);
                console.log('SDK.lookup method:', typeof skipifySDK.lookup);
                
                // Add more detailed logging and error handling
                console.log('Calling skipifySDK.lookup with params:', lookupParams);
                console.log('SDK lookup method type:', typeof skipifySDK.lookup);
                console.log('SDK lookup method function:', skipifySDK.lookup.toString().substring(0, 200));
                
                const lookupPromise = skipifySDK.lookup(lookupParams);
                console.log('Lookup promise created:', lookupPromise);
                console.log('Promise type:', typeof lookupPromise);
                console.log('Promise toString:', Object.prototype.toString.call(lookupPromise));
                
                // Set a timeout for the lookup (10 seconds to give more time)
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => {
                        console.log('‚è∞ Lookup timeout reached after 10 seconds');
                        reject(new Error('Lookup timed out after 10 seconds'));
                    }, 10000);
                });
                
                console.log('‚è≥ Waiting for lookup to complete...');
                showResult('lookupResult', '‚è≥ Waiting for Skipify response...', 'success');
                
                // Check for CSP (Content Security Policy) issues
                const metaTags = document.querySelectorAll('meta[http-equiv="Content-Security-Policy"]');
                if (metaTags.length > 0) {
                    metaTags.forEach((tag, index) => {
                        console.log(`üõ°Ô∏è CSP meta tag ${index}:`, tag.content);
                    });
                } else {
                    console.log('üõ°Ô∏è No CSP meta tags found');
                }
                
                // Check for any blocked content in browser console
                console.log('üîç Browser security info - check for any blocked content warnings above this line');
                
                // Monitor iframe communication
                console.log('üñºÔ∏è Checking for iframes on page...');
                const iframes = document.querySelectorAll('iframe');
                console.log(`Found ${iframes.length} iframes:`, iframes);
                
                // Add load/error listeners to existing iframes to see if they load later
                iframes.forEach((iframe, index) => {
                    console.log(`Setting up monitoring for existing iframe ${index}: ${iframe.src}`);
                    
                    // Set up listeners for existing iframes
                    iframe.addEventListener('load', () => {
                        console.log(`‚úÖ Existing iframe ${index} loaded: ${iframe.src}`);
                    });
                    
                    iframe.addEventListener('error', (e) => {
                        console.error(`‚ùå Existing iframe ${index} error:`, e, iframe.src);
                    });
                    
                    // Check current state
                    console.log(`Iframe ${index} current state:`, {
                        src: iframe.src,
                        readyState: iframe.readyState,
                        complete: iframe.complete,
                        contentWindow: !!iframe.contentWindow,
                        width: iframe.width || iframe.offsetWidth,
                        height: iframe.height || iframe.offsetHeight,
                        display: getComputedStyle(iframe).display,
                        visibility: getComputedStyle(iframe).visibility
                    });
                    
                    // Try to force iframe reload after a short delay
                    setTimeout(() => {
                        console.log(`üîÑ Force refreshing iframe ${index}...`);
                        const originalSrc = iframe.src;
                        iframe.src = 'about:blank';
                        setTimeout(() => {
                            iframe.src = originalSrc;
                            console.log(`üîÑ Iframe ${index} src reset to: ${originalSrc}`);
                        }, 100);
                    }, 1000 + (index * 500)); // Stagger the reloads
                });
                
                // Monitor for new iframes being added
                observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === 1 && node.tagName && node.tagName.toLowerCase() === 'iframe') {
                                console.log('üÜï New iframe added:', node.src);
                                
                                // Monitor this iframe's loading
                                node.onload = () => console.log('‚úÖ New iframe loaded:', node.src);
                                node.onerror = (e) => console.error('‚ùå New iframe error:', e, node.src);
                            }
                        });
                    });
                });
                observer.observe(document.body, { childList: true, subtree: true });
                
                // Monitor postMessage events (iframe communication)
                const messageHandler = (event) => {
                    console.log('üì® PostMessage received:', event.data, 'from origin:', event.origin);
                    
                    // Specifically look for lookup response
                    if (event.data && typeof event.data === 'object') {
                        if (event.data.name === '@skipify/lookup-response' || 
                            event.data.name === '@skipify/response-lookup-data' ||
                            event.data.name?.includes('lookup')) {
                            console.log('üéØ LOOKUP RESPONSE DETECTED:', event.data);
                        }
                        
                        // Log any error messages
                        if (event.data.name?.includes('error') || event.data.error) {
                            console.error('‚ùå Error message from iframe:', event.data);
                        }
                    }
                };
                window.addEventListener('message', messageHandler);
                
                // Also monitor for postMessage errors globally
                window.addEventListener('error', (e) => {
                    if (e.message && e.message.includes('postMessage')) {
                        console.error('üö® Global postMessage error detected:', e);
                    }
                });
                
                const result = await Promise.race([lookupPromise, timeoutPromise]);
                console.log('‚úÖ Lookup completed successfully:', result);
                
                // Validate the response structure
                if (!result) {
                    throw new Error('Lookup returned null or undefined result');
                }
                
                // Check for error response format
                if (result.error) {
                    throw new Error(`Lookup failed: ${result.error.message || 'Unknown error'}`);
                }
                
                // Format the response nicely with safe property access
                const formattedResult = `
                    <strong>‚úÖ Lookup successful!</strong><br><br>
                    <strong>Challenge ID:</strong> ${result.challengeId || 'Not provided'}<br>
                    <strong>Flags:</strong><br>
                    ‚Ä¢ Potential Payment Methods: ${result.flags?.potentialPaymentMethods ? 'Yes' : 'No'}<br>
                    ‚Ä¢ Phone Required: ${result.flags?.phoneRequired ? 'Yes' : 'No'}<br>
                    ‚Ä¢ Partner Provided Phone: ${result.flags?.partnerProvidedPhone ? 'Yes' : 'No'}<br>
                    <strong>Metadata:</strong><br>
                    ‚Ä¢ Masked Email: ${result.metadata?.maskedEmail || 'Not provided'}<br>
                    ‚Ä¢ Masked Phone: ${result.metadata?.maskedPhone || 'Not provided'}<br>
                    <strong>Defaults:</strong><br>
                    ‚Ä¢ Destination: ${result.defaults?.destination || 'Not provided'}<br>
                    ‚Ä¢ Masked Channel: ${result.defaults?.maskedChannel || 'Not provided'}<br>
                    <strong>Raw Response:</strong><br>
                    <pre>${JSON.stringify(result, null, 2)}</pre>
                    <strong>Network Activity:</strong><br>
                    ‚Ä¢ Total requests: ${networkRequests.length}<br>
                    ‚Ä¢ Requests: ${networkRequests.map(r => r.url).join(', ') || 'None'}
                `;
                
                // Restore network monitoring
                window.fetch = originalFetch;
                console.log('üìä Network requests during lookup:', networkRequests);
                
                showResult('lookupResult', formattedResult, 'success');
                
            } catch (error) {
                // Restore network monitoring on error
                window.fetch = originalFetch;
                console.log('üìä Network requests during failed lookup:', networkRequests);
                
                // Clean up message handler and observer, then check iframe status
                window.removeEventListener('message', messageHandler);
                if (observer) observer.disconnect();
                console.log('üñºÔ∏è Final iframe check at timeout...');
                const finalIframes = document.querySelectorAll('iframe');
                console.log(`Final iframe count: ${finalIframes.length}`);
                finalIframes.forEach((iframe, index) => {
                    console.log(`Iframe ${index}:`, {
                        src: iframe.src,
                        loaded: iframe.contentDocument !== null,
                        display: iframe.style.display,
                        dimensions: { width: iframe.width, height: iframe.height },
                        readyState: iframe.readyState,
                        onload: iframe.onload !== null
                    });
                    
                    // Check for iframe loading errors
                    iframe.onerror = (e) => console.error(`Iframe ${index} error:`, e);
                    iframe.onload = () => console.log(`Iframe ${index} loaded successfully!`);
                    
                    // Try to access iframe document safely
                    try {
                        const doc = iframe.contentDocument || iframe.contentWindow.document;
                        if (doc) {
                            console.log(`Iframe ${index} document:`, {
                                url: doc.URL,
                                title: doc.title,
                                readyState: doc.readyState
                            });
                        } else {
                            console.log(`Iframe ${index} document not accessible (CORS blocked)`);
                        }
                    } catch (error) {
                        console.log(`Iframe ${index} document access error:`, error.message);
                    }
                });
                
                // Test iframe URLs directly
                if (finalIframes.length > 0) {
                    const testUrl = finalIframes[0].src;
                    console.log(`üåê Testing iframe URL directly: ${testUrl}`);
                    fetch(testUrl, { mode: 'no-cors' })
                        .then(() => console.log('‚úÖ Iframe URL is reachable'))
                        .catch(err => console.error('‚ùå Iframe URL failed:', err));
                }
                
                console.error('Lookup error:', error);
                console.error('Error type:', typeof error);
                console.error('Error constructor:', error.constructor.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                
                if (error.message.includes('timed out')) {
                    const errorMessage = `‚ùå Lookup timed out after 10 seconds
                    
                    üìä Network Activity: ${networkRequests.length} requests
                    üåê Requests made: ${networkRequests.map(r => r.url).join(', ') || 'None'}
                    
                    üí° This suggests the SDK call is hanging. The SDK may be waiting for a response that never comes.`;
                    showResult('lookupResult', errorMessage, 'error');
                } else {
                    showResult('lookupResult', `‚ùå Lookup failed: ${error.message}
                    üìä Network requests: ${networkRequests.length}`, 'error');
                }
            }
        }

        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = message;
            element.className = `result ${type}`;
        }

        function testNetworkMonitoring() {
            try {
                showResult('networkResult', 'üîÑ Setting up network monitoring...', 'success');
                
                // Monitor fetch requests
                const originalFetch = window.fetch;
                let fetchCount = 0;
                let fetchRequests = [];
                
                window.fetch = function(...args) {
                    fetchCount++;
                    const request = {
                        id: fetchCount,
                        url: args[0],
                        options: args[1],
                        timestamp: new Date().toISOString()
                    };
                    fetchRequests.push(request);
                    console.log('Fetch request detected:', request);
                    
                    return originalFetch.apply(this, args).then(response => {
                        console.log('Fetch response received:', response);
                        return response;
                    }).catch(error => {
                        console.error('Fetch error:', error);
                        throw error;
                    });
                };
                
                // Monitor XMLHttpRequest
                const originalXHROpen = XMLHttpRequest.prototype.open;
                const originalXHRSend = XMLHttpRequest.prototype.send;
                let xhrCount = 0;
                let xhrRequests = [];
                
                XMLHttpRequest.prototype.open = function(method, url, ...args) {
                    xhrCount++;
                    this._requestId = xhrCount;
                    this._requestUrl = url;
                    this._requestMethod = method;
                    this._requestTimestamp = new Date().toISOString();
                    
                    const request = {
                        id: xhrCount,
                        method: method,
                        url: url,
                        timestamp: this._requestTimestamp
                    };
                    xhrRequests.push(request);
                    console.log('XHR request detected:', request);
                    
                    return originalXHROpen.apply(this, [method, url, ...args]);
                };
                
                XMLHttpRequest.prototype.send = function(data) {
                    console.log('XHR send called for request:', this._requestId, 'with data:', data);
                    return originalXHRSend.apply(this, [data]);
                };
                
                showResult('networkResult', `‚úÖ Network monitoring active. Fetch requests: ${fetchCount}, XHR requests: ${xhrCount}`, 'success');
                
                // Set up a periodic check
                const checkInterval = setInterval(() => {
                    const totalRequests = fetchRequests.length + xhrRequests.length;
                    showResult('networkResult', `‚úÖ Network monitoring active. Total requests: ${totalRequests}`, 'success');
                }, 2000);
                
                // Stop monitoring after 30 seconds
                setTimeout(() => {
                    clearInterval(checkInterval);
                    window.fetch = originalFetch;
                    XMLHttpRequest.prototype.open = originalXHROpen;
                    XMLHttpRequest.prototype.send = originalXHRSend;
                    
                    const summary = `
                        <strong>Network Monitoring Summary:</strong><br>
                        Fetch requests: ${fetchRequests.length}<br>
                        XHR requests: ${xhrRequests.length}<br>
                        Total requests: ${fetchRequests.length + xhrRequests.length}<br><br>
                        <strong>Fetch Requests:</strong><br>
                        ${fetchRequests.map(req => `${req.id}: ${req.url}`).join('<br>')}<br><br>
                        <strong>XHR Requests:</strong><br>
                        ${xhrRequests.map(req => `${req.id}: ${req.method} ${req.url}`).join('<br>')}
                    `;
                    
                    showResult('networkResult', summary, 'success');
                }, 30000);
                
            } catch (error) {
                console.error('Network monitoring error:', error);
                showResult('networkResult', `‚ùå Network monitoring failed: ${error.message}`, 'error');
            }
        }

        function testDeepInspection() {
            try {
                showResult('inspectionResult', 'üîÑ Performing deep SDK inspection...', 'success');
                
                if (!skipifySDK) {
                    showResult('inspectionResult', '‚ùå SDK not initialized', 'error');
                    return;
                }
                
                let inspectionResults = [];
                
                // Custom function to safely stringify objects with circular references
                function safeStringify(obj, maxDepth = 3, currentDepth = 0) {
                    if (currentDepth >= maxDepth) return '[Max Depth Reached]';
                    if (obj === null) return 'null';
                    if (typeof obj !== 'object') return String(obj);
                    
                    try {
                        // Try normal JSON.stringify first
                        return JSON.stringify(obj, null, 2);
                    } catch (error) {
                        if (error.message.includes('circular')) {
                            // Handle circular references
                            const seen = new WeakSet();
                            const replacer = (key, value) => {
                                if (typeof value === 'object' && value !== null) {
                                    if (seen.has(value)) {
                                        return '[Circular Reference]';
                                    }
                                    seen.add(value);
                                }
                                return value;
                            };
                            try {
                                return JSON.stringify(obj, replacer, 2);
                            } catch (e) {
                                return '[Circular Reference - Cannot Serialize]';
                            }
                        }
                        return `[Error: ${error.message}]`;
                    }
                }
                
                // 1. Basic SDK info
                inspectionResults.push(`<strong>Basic SDK Info:</strong>`);
                inspectionResults.push(`Constructor: ${skipifySDK.constructor.name}`);
                inspectionResults.push(`Type: ${typeof skipifySDK}`);
                inspectionResults.push(`Prototype: ${Object.getPrototypeOf(skipifySDK).constructor.name}`);
                
                // 2. All properties and methods (safely)
                inspectionResults.push(`<br><strong>All Properties and Methods:</strong>`);
                const allProps = Object.getOwnPropertyNames(skipifySDK);
                const allSymbols = Object.getOwnPropertySymbols(skipifySDK);
                inspectionResults.push(`Own properties: ${allProps.length}`);
                inspectionResults.push(`Own symbols: ${allSymbols.length}`);
                
                allProps.forEach(prop => {
                    try {
                        const value = skipifySDK[prop];
                        const type = typeof value;
                        if (type === 'function') {
                            inspectionResults.push(`‚Ä¢ ${prop}: function (${value.name || 'anonymous'})`);
                        } else if (type === 'object' && value !== null) {
                            // For objects, just show the type and a few keys if it's safe
                            try {
                                const keys = Object.keys(value);
                                inspectionResults.push(`‚Ä¢ ${prop}: object with ${keys.length} keys: ${keys.slice(0, 5).join(', ')}${keys.length > 5 ? '...' : ''}`);
                            } catch (e) {
                                inspectionResults.push(`‚Ä¢ ${prop}: object [Circular Reference]`);
                            }
                        } else {
                            inspectionResults.push(`‚Ä¢ ${prop}: ${type} = ${safeStringify(value, 1)}`);
                        }
                    } catch (error) {
                        inspectionResults.push(`‚Ä¢ ${prop}: [Error accessing: ${error.message}]`);
                    }
                });
                
                // 3. Prototype chain (safely)
                inspectionResults.push(`<br><strong>Prototype Chain:</strong>`);
                try {
                    let proto = Object.getPrototypeOf(skipifySDK);
                    let level = 1;
                    while (proto && proto !== Object.prototype && level <= 3) {
                        inspectionResults.push(`Level ${level}: ${proto.constructor.name}`);
                        try {
                            const protoProps = Object.getOwnPropertyNames(proto);
                            inspectionResults.push(`  Properties: ${protoProps.join(', ')}`);
                        } catch (e) {
                            inspectionResults.push(`  Properties: [Error accessing: ${e.message}]`);
                        }
                        proto = Object.getPrototypeOf(proto);
                        level++;
                    }
                } catch (error) {
                    inspectionResults.push(`[Error accessing prototype chain: ${error.message}]`);
                }
                
                // 4. Lookup method analysis
                inspectionResults.push(`<br><strong>Lookup Method Analysis:</strong>`);
                if (typeof skipifySDK.lookup === 'function') {
                    inspectionResults.push(`‚úÖ Lookup method exists`);
                    inspectionResults.push(`Function name: ${skipifySDK.lookup.name || 'anonymous'}`);
                    inspectionResults.push(`Function length: ${skipifySDK.lookup.length}`);
                    try {
                        const funcStr = skipifySDK.lookup.toString();
                        inspectionResults.push(`Function toString: ${funcStr.substring(0, 200)}...`);
                    } catch (e) {
                        inspectionResults.push(`Function toString: [Error: ${e.message}]`);
                    }
                } else {
                    inspectionResults.push(`‚ùå Lookup method not found`);
                }
                
                // 5. Check for common SDK properties (safely)
                inspectionResults.push(`<br><strong>Common SDK Properties:</strong>`);
                const commonProps = ['config', 'merchantId', 'environment', 'api', 'messenger', 'deviceId', 'sessionId', 'ready', 'initialized'];
                commonProps.forEach(prop => {
                    try {
                        if (prop in skipifySDK) {
                            const value = skipifySDK[prop];
                            const type = typeof value;
                            if (type === 'object' && value !== null) {
                                inspectionResults.push(`‚Ä¢ ${prop}: ${type} [Complex Object]`);
                            } else {
                                inspectionResults.push(`‚Ä¢ ${prop}: ${type} = ${safeStringify(value, 1)}`);
                            }
                        } else {
                            inspectionResults.push(`‚Ä¢ ${prop}: not found`);
                        }
                    } catch (error) {
                        inspectionResults.push(`‚Ä¢ ${prop}: [Error accessing: ${error.message}]`);
                    }
                });
                
                // 6. Check for iframe-related properties (safely)
                inspectionResults.push(`<br><strong>Iframe/UI Related Properties:</strong>`);
                const iframeProps = ['iframe', 'container', 'element', 'dom', 'ui', 'render', 'show', 'hide'];
                iframeProps.forEach(prop => {
                    try {
                        if (prop in skipifySDK) {
                            const value = skipifySDK[prop];
                            const type = typeof value;
                            if (type === 'object' && value !== null) {
                                inspectionResults.push(`‚Ä¢ ${prop}: ${type} [Complex Object]`);
                            } else {
                                inspectionResults.push(`‚Ä¢ ${prop}: ${type} = ${safeStringify(value, 1)}`);
                            }
                        } else {
                            inspectionResults.push(`‚Ä¢ ${prop}: not found`);
                        }
                    } catch (error) {
                        inspectionResults.push(`‚Ä¢ ${prop}: [Error accessing: ${error.message}]`);
                    }
                });
                
                // 7. Check SDK state and readiness
                inspectionResults.push(`<br><strong>SDK State Analysis:</strong>`);
                try {
                    // Check if SDK has any state indicators
                    const stateProps = ['ready', 'initialized', 'loading', 'error', 'status'];
                    stateProps.forEach(prop => {
                        if (prop in skipifySDK) {
                            const value = skipifySDK[prop];
                            inspectionResults.push(`‚Ä¢ ${prop}: ${safeStringify(value, 1)}`);
                        }
                    });
                    
                    // Check if SDK has any event listeners or callbacks
                    const callbackProps = ['onReady', 'onError', 'onLoad', 'callback', 'listener'];
                    callbackProps.forEach(prop => {
                        if (prop in skipifySDK) {
                            const value = skipifySDK[prop];
                            inspectionResults.push(`‚Ä¢ ${prop}: ${typeof value}`);
                        }
                    });
                } catch (error) {
                    inspectionResults.push(`[Error analyzing SDK state: ${error.message}]`);
                }
                
                showResult('inspectionResult', inspectionResults.join('<br>'), 'success');
                
            } catch (error) {
                console.error('Deep inspection error:', error);
                showResult('inspectionResult', `‚ùå Deep inspection failed: ${error.message}`, 'error');
            }
        }

        async function testAlternativeLookup() {
            try {
                showResult('alternativeLookupResult', 'üîÑ Testing alternative lookup approaches...', 'success');
                
                if (!skipifySDK) {
                    showResult('alternativeLookupResult', '‚ùå SDK not initialized', 'error');
                    return;
                }
                
                let results = [];
                
                // Test 1: Try calling lookup with different parameters
                results.push(`<strong>Test 1: Different Parameters</strong>`);
                try {
                    console.log('Testing lookup with different parameters...');
                    const testPromise = skipifySDK.lookup('test@example.com');
                    console.log('Lookup promise created with string parameter');
                    
                    // Set a short timeout for this test
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ String parameter worked: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå String parameter failed: ${error.message}`);
                }
                
                // Test 2: Try calling lookup with different object structure
                results.push(`<br><strong>Test 2: Different Object Structure</strong>`);
                try {
                    console.log('Testing lookup with different object structure...');
                    const testPromise = skipifySDK.lookup({ email: 'test@example.com', phone: '1234567890' });
                    console.log('Lookup promise created with full object');
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Full object worked: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Full object failed: ${error.message}`);
                }
                
                // Test 3: Try calling lookup with empty object
                results.push(`<br><strong>Test 3: Empty Object</strong>`);
                try {
                    console.log('Testing lookup with empty object...');
                    const testPromise = skipifySDK.lookup({});
                    console.log('Lookup promise created with empty object');
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Empty object worked: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Empty object failed: ${error.message}`);
                }
                
                // Test 4: Try calling lookup with no parameters
                results.push(`<br><strong>Test 4: No Parameters</strong>`);
                try {
                    console.log('Testing lookup with no parameters...');
                    const testPromise = skipifySDK.lookup();
                    console.log('Lookup promise created with no parameters');
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ No parameters worked: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå No parameters failed: ${error.message}`);
                }
                
                // Test 5: Try calling lookup with callback style
                results.push(`<br><strong>Test 5: Callback Style</strong>`);
                try {
                    console.log('Testing lookup with callback style...');
                    const testPromise = new Promise((resolve, reject) => {
                        skipifySDK.lookup({ email: 'test@example.com' }, (error, result) => {
                            if (error) reject(error);
                            else resolve(result);
                        });
                    });
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Callback style worked: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Callback style failed: ${error.message}`);
                }
                
                showResult('alternativeLookupResult', results.join('<br>'), 'success');
                
            } catch (error) {
                console.error('Alternative lookup test error:', error);
                showResult('alternativeLookupResult', `‚ùå Alternative lookup test failed: ${error.message}`, 'error');
            }
        }

        async function testTargetedLookup() {
            try {
                showResult('targetedLookupResult', 'üîÑ Testing targeted lookup approaches...', 'success');
                
                if (!skipifySDK) {
                    showResult('targetedLookupResult', '‚ùå SDK not initialized', 'error');
                    return;
                }

                let results = [];

                // Test 1: Direct call with email
                results.push(`<strong>Test 1: Direct Call with Email</strong>`);
                try {
                    console.log('Testing direct lookup with email...');
                    const testPromise = skipifySDK.lookup('test@example.com');
                    console.log('Lookup promise created with string parameter');
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Direct string lookup successful: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Direct string lookup failed: ${error.message}`);
                }

                // Test 2: Direct call with object
                results.push(`<br><strong>Test 2: Direct Call with Object</strong>`);
                try {
                    console.log('Testing direct lookup with object...');
                    const testPromise = skipifySDK.lookup({ email: 'test@example.com', phone: '1234567890' });
                    console.log('Lookup promise created with full object');
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Direct object lookup successful: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Direct object lookup failed: ${error.message}`);
                }

                // Test 3: Direct call with empty object
                results.push(`<br><strong>Test 3: Direct Call with Empty Object</strong>`);
                try {
                    console.log('Testing direct lookup with empty object...');
                    const testPromise = skipifySDK.lookup({});
                    console.log('Lookup promise created with empty object');
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Direct empty object lookup successful: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Direct empty object lookup failed: ${error.message}`);
                }

                // Test 4: Direct call with no parameters
                results.push(`<br><strong>Test 4: Direct Call with No Parameters</strong>`);
                try {
                    console.log('Testing direct lookup with no parameters...');
                    const testPromise = skipifySDK.lookup();
                    console.log('Lookup promise created with no parameters');
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Direct no parameters lookup successful: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Direct no parameters lookup failed: ${error.message}`);
                }

                // Test 5: Direct call with callback style
                results.push(`<br><strong>Test 5: Direct Call with Callback Style</strong>`);
                try {
                    console.log('Testing direct lookup with callback style...');
                    const testPromise = new Promise((resolve, reject) => {
                        skipifySDK.lookup({ email: 'test@example.com' }, (error, result) => {
                            if (error) reject(error);
                            else resolve(result);
                        });
                    });
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout after 5 seconds')), 5000);
                    });
                    
                    const result = await Promise.race([testPromise, timeoutPromise]);
                    results.push(`‚úÖ Direct callback style lookup successful: ${JSON.stringify(result)}`);
                } catch (error) {
                    results.push(`‚ùå Direct callback style lookup failed: ${error.message}`);
                }

                showResult('targetedLookupResult', results.join('<br>'), 'success');

            } catch (error) {
                console.error('Targeted lookup test error:', error);
                showResult('targetedLookupResult', `‚ùå Targeted lookup test failed: ${error.message}`, 'error');
            }
        }

        async function testIframeStatus() {
            try {
                showResult('iframeStatusResult', 'üîÑ Checking iframe status...', 'success');
                
                if (!skipifySDK) {
                    showResult('iframeStatusResult', '‚ùå SDK not initialized', 'error');
                    return;
                }

                let results = [];
                
                // Check if SDK has an iframe property
                if (skipifySDK.iframe) {
                    const iframeElement = skipifySDK.iframe;
                    results.push(`‚úÖ SDK has an iframe property`);
                    
                    // Check if iframe is visible
                    if (iframeElement.style.display !== 'none' && iframeElement.style.visibility !== 'hidden') {
                        results.push(`‚úÖ Iframe is visible`);
                    } else {
                        results.push(`‚ùå Iframe is hidden`);
                    }
                    
                    // Check if iframe has a contentWindow
                    if (iframeElement.contentWindow) {
                        results.push(`‚úÖ Iframe has a contentWindow`);
                    } else {
                        results.push(`‚ùå Iframe does not have a contentWindow`);
                    }
                    
                    // Check if iframe has a document
                    if (iframeElement.contentDocument) {
                        results.push(`‚úÖ Iframe has a document`);
                    } else {
                        results.push(`‚ùå Iframe does not have a document`);
                    }
                    
                } else {
                    results.push(`‚ùå SDK does not have an iframe property`);
                }
                
                // Check messenger properties
                if (skipifySDK.messenger) {
                    results.push(`‚úÖ SDK has a messenger property`);
                    
                    const messenger = skipifySDK.messenger;
                    const messengerProps = ['isReady', 'isInitialized', 'isLoading', 'isError', 'isCarousel', 'isAuthentication'];
                    
                    messengerProps.forEach(prop => {
                        if (prop in messenger) {
                            results.push(`‚úÖ Messenger.${prop}: ${messenger[prop]}`);
                        } else {
                            results.push(`‚ùå Messenger.${prop}: not found`);
                        }
                    });
                } else {
                    results.push(`‚ùå SDK does not have a messenger property`);
                }
                
                showResult('iframeStatusResult', results.join('<br>'), 'success');
                
            } catch (error) {
                console.error('Iframe status test error:', error);
                showResult('iframeStatusResult', `‚ùå Iframe status test failed: ${error.message}`, 'error');
            }
        }
    </script>
</html> 