<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skipify Test Chat App - Simple Version</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .chat-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 600px;
        }
        .chat-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            margin: -30px -30px 20px -30px;
        }
        .chat-messages {
            height: 300px;
            overflow-y: auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            max-width: 80%;
        }
        .message.user {
            background: #007bff;
            color: white;
            margin-left: auto;
        }
        .message.assistant {
            background: #f8f9fa;
            color: #333;
            margin-right: auto;
        }
        .message.system {
            background: #ffc107;
            color: #212529;
            font-style: italic;
            text-align: center;
            margin: 10px auto;
        }
        .chat-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .chat-input button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .chat-input button:hover {
            background: #0056b3;
        }
        .skipify-controls {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .control-group {
            margin: 10px 0;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .control-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-bottom: 10px;
        }
        .control-group button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 10px;
        }
        .control-group button:hover {
            background: #218838;
        }
        .session-info {
            display: none;
            padding: 15px;
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .result-display {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .result-display .success {
            color: #155724;
            background: #d4edda;
            padding: 10px;
            border-radius: 3px;
        }
        .result-display .error {
            color: #721c24;
            background: #f8d7da;
            padding: 10px;
            border-radius: 3px;
        }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>üöÄ Skipify Test Chat App</h1>
            <p>Test the Skipify Embedded Components SDK Integration</p>
        </div>

        <div class="session-info" id="sessionInfo">
            <h4>üìã Session Information:</h4>
            <p><strong>Session ID:</strong> <span id="sessionId">None</span></p>
            <p><strong>Merchant ID:</strong> <span id="merchantId">None</span></p>
        </div>

        <div class="skipify-controls">
            <h3>‚öôÔ∏è Configuration</h3>
            <div class="control-group">
                <label for="merchantIdInput">Merchant ID:</label>
                <input type="text" id="merchantIdInput" value="1bdc8b60-6dd4-4126-88e1-c9e5b570f1a0" placeholder="Enter merchant ID">
                <button onclick="createSession()">Create Chat Session</button>
            </div>
        </div>

        <div class="skipify-controls">
            <h3>üîç Skipify SDK Operations</h3>
            
            <div class="control-group">
                <label for="lookupEmail">Email:</label>
                <input type="email" id="lookupEmail" placeholder="Enter email for lookup" value="nick.suess@skipify.com">
                <label for="lookupPhone">Phone (optional):</label>
                <input type="tel" id="lookupPhone" placeholder="Enter phone for lookup">
                <button onclick="testLookup()">üîç Test Lookup</button>
                <button onclick="testReliableLookup()">‚úÖ Reliable Lookup</button>
            </div>

            <div class="control-group">
                <label for="authChallengeId">Challenge ID:</label>
                <input type="text" id="authChallengeId" placeholder="Challenge ID from lookup">
                <label for="authPhone">Phone:</label>
                <input type="tel" id="authPhone" placeholder="Phone for authentication">
                <button onclick="testAuth()">üîê Test Authentication</button>
                
                <!-- Authentication component container positioned right below the button -->
                <div id="skipify-auth-container" style="display: none; margin: 20px 0; padding: 20px; border: 2px solid #007bff; border-radius: 10px; background: #f8f9fa;">
                    <h4>üîê Authentication Component</h4>
                    <div id="skipify-auth-content"></div>
                </div>
            </div>

            <div class="control-group">
                <label for="carouselAmount">Amount (cents):</label>
                <input type="number" id="carouselAmount" value="1000" placeholder="Amount in cents">
                <label for="carouselPhone">Phone:</label>
                <input type="tel" id="carouselPhone" placeholder="Phone for carousel" value="+1234567890">
                <button onclick="testCarousel()">üí≥ Test Carousel</button>
                
                <!-- Carousel component container will be dynamically created here -->
                <div id="carousel-container-placeholder"></div>
            </div>

            <div class="control-group">
                <button onclick="testDeviceId()">üì± Get Device ID</button>
            </div>
            
            <div class="control-group">
                <button onclick="debugSDK()">üîç Debug SDK</button>
            </div>
        </div>

        <div class="chat-messages" id="messages">
            <div class="message system">Welcome! Create a session and start testing Skipify operations.</div>
        </div>

        <div class="chat-input">
            <input type="text" id="messageInput" placeholder="Type your message..." onkeypress="if(event.key==='Enter') sendMessage()">
            <button onclick="sendMessage()">Send</button>
        </div>

        <div class="result-display" id="resultDisplay">
            <h4>üìä Skipify Operation Result:</h4>
            <div id="resultContent"></div>
        </div>


    </div>

    <!-- Load Skipify SDK from CDN using regular script loading to avoid CORS issues -->
    <script type="text/javascript">
        // Load the SDK using a regular script tag to avoid CORS issues
        const sdkScript = document.createElement('script');
        sdkScript.src = `https://stagecdn.skipify.com/sdk/components-sdk.js?date=${new Date().getTime()}`;
        sdkScript.onload = function() {
            console.log('SDK script loaded successfully');
        };
        sdkScript.onerror = function() {
            console.error('Failed to load SDK script');
        };
        document.head.appendChild(sdkScript);
    </script>

    <!-- Configuration Script -->
    <script src="config.js"></script>

    <script>
        let currentSession = null;
        let skipifySessionId = null;
        let skipifySDK = null;
        let lookupResults = null; // Store the actual lookup results
        let storedChallengeId = null; // Store challenge ID from lookup for automatic auth

        // Wait for the SDK to load (replicating the working playground approach)
        function waitForSDK() {
            return new Promise((resolve, reject) => {
                const checkSDK = () => {
                    if (window.skipify) {
                        console.log('SDK loaded successfully');
                        resolve(window.skipify);
                    } else {
                        console.log('SDK not yet loaded, checking again...');
                        setTimeout(checkSDK, 100);
                    }
                };
                checkSDK();
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    reject(new Error('SDK failed to load within 10 seconds'));
                }, 10000);
            });
        }

        // Initialize Skipify SDK when page loads (replicating the working playground)
        window.addEventListener('load', async function() {
            console.log('Page loaded, waiting for SDK...');
            
            try {
                const Skipify = await waitForSDK();
                console.log('SDK constructor available:', Skipify);
                
                // Use the exact same configuration as the working playground
                const config = {
                    merchantId: '1bdc8b60-6dd4-4126-88e1-c9e5b570f1a0',
                    environment: 'stage'
                    // Removed fingerprinting disable options to avoid potential conflicts
                };
                
                console.log('Initializing SDK with config:', config);
                skipifySDK = new Skipify(config);
                
                addMessage('system', '‚úÖ Skipify SDK loaded successfully from CDN');
                
                console.log('Skipify SDK initialized:', skipifySDK);
                console.log('SDK constructor:', skipifySDK.constructor.name);
                console.log('SDK prototype methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(skipifySDK)));
                console.log('SDK instance properties:', Object.keys(skipifySDK));
                
                // Check if SDK has a start method
                if (typeof skipifySDK.start === 'function') {
                    console.log('SDK has start method');
                } else {
                    console.log('SDK does not have start method');
                }
                
                // Check if SDK has a lookup method
                if (typeof skipifySDK.lookup === 'function') {
                    console.log('SDK has lookup method');
                } else {
                    console.log('SDK does not have lookup method');
                }
                
                // Wait a bit for the SDK to be fully ready
                setTimeout(() => {
                    addMessage('system', 'üîÑ SDK initialization complete - ready for operations');
                    console.log('SDK ready for operations');
                }, 2000);
                
            } catch (error) {
                console.error('Error initializing Skipify SDK:', error);
                addMessage('system', `‚ùå Error initializing Skipify SDK: ${error.message}`);
            }
        });

        async function createSession() {
            const merchantId = document.getElementById('merchantIdInput').value;
            
            try {
                const response = await fetch(`${window.APP_CONFIG.BACKEND_URL}/api/chat/sessions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        merchantId,
                        initialMessage: 'Hello! I want to test the Skipify SDK'
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const session = await response.json();
                currentSession = session;
                
                // Update UI
                document.getElementById('sessionId').textContent = session.id;
                document.getElementById('merchantId').textContent = session.merchantId || 'None';
                document.getElementById('sessionInfo').style.display = 'block';
                
                // Add messages to chat
                const messagesDiv = document.getElementById('messages');
                messagesDiv.innerHTML = '';
                
                session.messages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${msg.type}`;
                    messageDiv.innerHTML = `
                        <div><strong>${msg.type.toUpperCase()}:</strong></div>
                        <div>${msg.content}</div>
                        <div style="font-size: 12px; opacity: 0.7; margin-top: 5px;">
                            ${new Date(msg.timestamp).toLocaleTimeString()}
                        </div>
                    `;
                    messagesDiv.appendChild(messageDiv);
                });
                
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                
                addMessage('system', 'Chat session created successfully! You can now send messages and test Skipify operations.');
                
            } catch (error) {
                console.error('Error creating session:', error);
                addMessage('system', `Error creating session: ${error.message}`);
            }
        }

        async function sendMessage() {
            if (!currentSession) {
                addMessage('system', 'Please create a chat session first.');
                return;
            }
            
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            
            if (!message) return;
            
            // Add user message immediately
            addMessage('user', message);
            messageInput.value = '';
            
            try {
                const response = await fetch(`${window.APP_CONFIG.BACKEND_URL}/api/chat/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: currentSession.id,
                        message: message
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const assistantMessage = await response.json();
                addMessage('assistant', assistantMessage.content);
                
                // Check if we need to execute a Skipify SDK operation
                if (assistantMessage.metadata && assistantMessage.metadata.executeSDK) {
                    console.log('ü§ñ Chat assistant detected SDK operation:', assistantMessage.metadata);
                    await executeSkipifyAction(assistantMessage.metadata);
                }
                
            } catch (error) {
                console.error('Error sending message:', error);
                addMessage('system', `Error sending message: ${error.message}`);
            }
        }

        function addMessage(type, content) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.innerHTML = `
                <div><strong>${type.toUpperCase()}:</strong></div>
                <div>${content}</div>
                <div style="font-size: 12px; opacity: 0.7; margin-top: 5px;">
                    ${new Date().toLocaleTimeString()}
                </div>
            `;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        /**
         * Execute Skipify SDK actions based on chat assistant instructions
         */
        async function executeSkipifyAction(metadata) {
            const { skipifyAction, parameters } = metadata;
            
            if (!skipifySDK) {
                addMessage('system', '‚ùå Skipify SDK not loaded - cannot execute operation');
                return;
            }
            
            addMessage('system', `üöÄ Executing ${skipifyAction} operation via frontend SDK...`);
            
            try {
                switch (skipifyAction) {
                    case 'lookup':
                        await executeSDKLookup(parameters);
                        break;
                    case 'auth':
                        await executeSDKAuth(parameters);
                        break;
                    case 'carousel':
                        await executeSDKCarousel(parameters);
                        break;
                    case 'card_selection':
                        await executeSDKCardSelection(parameters);
                        break;
                    case 'device_id':
                        await executeSDKDeviceId();
                        break;
                    default:
                        addMessage('system', `‚ùå Unknown SDK action: ${skipifyAction}`);
                }
            } catch (error) {
                console.error('Error executing SDK action:', error);
                addMessage('system', `‚ùå Error executing ${skipifyAction}: ${error.message}`);
            }
        }

        /**
         * Execute SDK lookup and provide natural language results
         */
        async function executeSDKLookup(parameters) {
            const { email, phone } = parameters;
            
            try {
                const lookupParams = {};
                if (email) lookupParams.email = email;
                if (phone) lookupParams.phone = phone;
                
                console.log('üîç Executing SDK lookup with params:', lookupParams);
                
                const result = await Promise.race([
                    skipifySDK.lookup(lookupParams),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Lookup timed out after 5 seconds')), 5000))
                ]);
                
                // Generate natural language response
                const hasPaymentMethods = result.flags?.potentialPaymentMethods || false;
                const contact = email || phone;
                
                let responseText = `‚úÖ **Lookup Results for ${contact}:**\n\n`;
                
                if (hasPaymentMethods) {
                    responseText += `üéâ **Yes! This shopper has payment methods available.**\n\n`;
                } else {
                    responseText += `‚ùå **No payment methods found for this shopper.**\n\n`;
                }
                
                responseText += `**Details:**\n`;
                responseText += `‚Ä¢ Challenge ID: ${result.challengeId || 'None'}\n`;
                responseText += `‚Ä¢ Payment Methods: ${hasPaymentMethods ? '‚úÖ Available' : '‚ùå None found'}\n`;
                responseText += `‚Ä¢ Phone Required: ${result.flags?.phoneRequired ? 'Yes' : 'No'}\n`;
                
                if (result.metadata?.maskedEmail) {
                    responseText += `‚Ä¢ Masked Email: ${result.metadata.maskedEmail}\n`;
                }
                if (result.metadata?.maskedPhone) {
                    responseText += `‚Ä¢ Masked Phone: ${result.metadata.maskedPhone}\n`;
                }
                
                if (hasPaymentMethods && result.challengeId) {
                    responseText += `\nüéØ **Next Step:** You can now authenticate this shopper by simply saying:\n*"Authenticate the shopper"* or *"Start authentication"*`;
                }
                
                addMessage('assistant', responseText);
                
                // Store results for further operations
                lookupResults = result;
                storedChallengeId = result.challengeId; // Store challenge ID for automatic auth
                if (result.challengeId) {
                    document.getElementById('authChallengeId').value = result.challengeId;
                    console.log('üîë Stored challenge ID for automatic authentication:', result.challengeId);
                }
                
            } catch (error) {
                console.error('SDK lookup error:', error);
                addMessage('assistant', `‚ùå **Lookup failed:** ${error.message}\n\nüí° This might be due to network issues or the email not being in the Skipify network.`);
            }
        }

        /**
         * Execute SDK authentication
         */
        async function executeSDKAuth(parameters) {
            const { challengeId, phone } = parameters;
            
            // Use provided challenge ID or fall back to stored one from lookup
            const finalChallengeId = challengeId || storedChallengeId;
            
            if (!finalChallengeId) {
                addMessage('assistant', '‚ùå **Challenge ID required for authentication.** Please perform a lookup first to get a challenge ID, then try authentication again.');
                return;
            }
            
            // If using stored challenge ID, inform the user
            if (!challengeId && storedChallengeId) {
                console.log('üîë Using stored challenge ID from previous lookup:', storedChallengeId);
                addMessage('system', 'üîë Using challenge ID from previous lookup automatically');
            }
            
            if (!skipifySDK) {
                addMessage('assistant', '‚ùå **Skipify SDK not loaded** - cannot perform authentication.');
                return;
            }
            
            // Auto-populate the auth form 
            document.getElementById('authChallengeId').value = finalChallengeId;
            if (phone) {
                document.getElementById('authPhone').value = phone;
            }
            
            addMessage('assistant', 'üîê **Starting authentication process...** The authentication component will appear below the auth button.');
            
            try {
                // Check if we have stored lookup results (required for authentication)
                if (!lookupResults) {
                    addMessage('assistant', '‚ùå **Lookup results required for authentication.** Please perform a lookup first to get the full context needed for authentication.');
                    return;
                }
                
                // Use the stored lookup results as base (same as working UI authentication)
                const authParams = { ...lookupResults };
                
                // Set the challenge ID (either provided or stored from lookup)
                authParams.challengeId = finalChallengeId;
                
                // Add phone if provided
                if (phone) {
                    authParams.phone = phone;
                }
                
                console.log('üîê Executing SDK authentication with FULL lookup context:', authParams);
                
                // Call authentication with the complete lookup results (same as working UI)
                const result = await skipifySDK.authentication(authParams, {
                    onSuccess: (data) => {
                        console.log('Authentication success:', data);
                        // Store authentication result for carousel use
                        window.authenticationResult = data;
                        
                        let responseText = `‚úÖ **Authentication completed successfully!**\n\n`;
                        responseText += `**Authentication Results:**\n`;
                        responseText += `‚Ä¢ Shopper ID: ${data.shopperId || 'Retrieved'}\n`;
                        responseText += `‚Ä¢ Session ID: ${data.sessionId || 'Active'}\n\n`;
                        responseText += `üéØ **Next Step:** You can now show payment options by saying:\n*"Show payment carousel for $25"*`;
                        
                        addMessage('assistant', responseText);
                        showResult('auth', { success: true, data: data });
                    },
                    onError: (error) => {
                        console.error('Authentication error:', error);
                        addMessage('assistant', `‚ùå **Authentication failed:** ${error.message || error}\n\nüí° Please try again or check the challenge ID.`);
                        showResult('auth', { error: error.message || error });
                    },
                    onCancel: () => {
                        console.log('Authentication cancelled');
                        addMessage('assistant', '‚ö†Ô∏è **Authentication was cancelled by the user.**');
                        showResult('auth', { cancelled: true });
                    },
                    displayMode: 'embedded',
                    config: {
                        theme: "light",
                        fontFamily: "default",
                        fontSize: "medium"
                    }
                });
                
                // Show the auth container
                const authContainer = document.getElementById('skipify-auth-container');
                const authContent = document.getElementById('skipify-auth-content');
                if (authContainer) {
                    authContainer.style.display = 'block';
                    addMessage('system', 'üì± Authentication component is now visible below the auth button');
                }
                
                // Check if the result contains a render function
                if (result && typeof result.render === 'function') {
                    console.log('üé® Calling render function to display authentication component');
                    
                    if (authContent) {
                        // Call the render function with the auth content container
                        try {
                            result.render(authContent);
                            console.log('‚úÖ Authentication component rendered successfully');
                        } catch (renderError) {
                            console.error('Error rendering auth component:', renderError);
                            addMessage('assistant', `‚ùå **Error displaying authentication component:** ${renderError.message}`);
                        }
                    }
                }
                
            } catch (error) {
                console.error('SDK authentication error:', error);
                addMessage('assistant', `‚ùå **Authentication failed:** ${error.message}\n\nüí° Please check the challenge ID and try again.`);
                showResult('auth', { error: error.message });
            }
        }

        /**
         * Execute SDK carousel
         */
        async function executeSDKCarousel(parameters) {
            const { amount, phone } = parameters;
            
            // Auto-populate the carousel form and trigger it
            if (amount) {
                document.getElementById('carouselAmount').value = amount;
            }
            if (phone) {
                document.getElementById('carouselPhone').value = phone;
            }
            
            addMessage('assistant', 'üí≥ **Loading payment carousel...** Available payment methods will appear below the carousel button.');
            
            // Trigger the existing carousel function
            await testCarousel();
        }

        /**
         * Execute SDK device ID
         */
        async function executeSDKDeviceId() {
            addMessage('assistant', 'üì± **Getting device ID...** This will generate a unique identifier for this browser session.');
            
            // Trigger the existing device ID function
            await testDeviceId();
        }

        /**
         * Execute SDK card selection from payment carousel
         */
        async function executeSDKCardSelection(parameters) {
            const { cardIndex, cardType, cardEnding } = parameters;
            
            let responseText = `üí≥ **Selecting payment method...** `;
            
            if (cardIndex && cardType && cardEnding) {
                responseText += `Looking for ${cardType} card at position ${cardIndex} ending in ${cardEnding}`;
            } else if (cardIndex && cardType) {
                responseText += `Looking for ${cardType} card at position ${cardIndex}`;
            } else if (cardIndex && cardEnding) {
                responseText += `Looking for payment method at position ${cardIndex} ending in ${cardEnding}`;
            } else if (cardType && cardEnding) {
                responseText += `Looking for ${cardType} card ending in ${cardEnding}`;
            } else if (cardIndex) {
                responseText += `Selecting payment method at position ${cardIndex}`;
            } else if (cardType) {
                responseText += `Looking for ${cardType} card`;
            } else if (cardEnding) {
                responseText += `Looking for card ending in ${cardEnding}`;
            } else {
                responseText += `Selecting first available payment method`;
            }
            
            addMessage('assistant', responseText);
            
            // First, check if carousel iframe exists
            const carouselIframe = document.getElementById('_SKIPIFY_carousel_iframe');
            if (!carouselIframe) {
                addMessage('assistant', '‚ùå **Payment carousel iframe not found.** Please display the payment carousel first by saying: *"Show payment options for $25"*');
                return;
            }
            
            console.log('üéØ Found Skipify carousel iframe:', carouselIframe);
            addMessage('system', 'üéØ Found Skipify carousel iframe - attempting card selection...');
            
            try {
                // Strategy 1: Set up event listeners to detect successful selection
                let selectionDetected = false;
                const originalPostMessage = window.postMessage;
                
                // Listen for postMessage events that might indicate selection
                const messageListener = (event) => {
                    if (event.origin === 'https://checkout.staging.skipify.com') {
                        console.log('üéØ Received message from Skipify iframe:', event.data);
                        if (event.data && (event.data.name?.includes('selection') || event.data.type?.includes('card'))) {
                            selectionDetected = true;
                            addMessage('system', '‚úÖ Card selection event detected from iframe!');
                        }
                    }
                };
                
                window.addEventListener('message', messageListener);
                
                // Clean up listener after attempts
                setTimeout(() => {
                    window.removeEventListener('message', messageListener);
                    if (selectionDetected) {
                        addMessage('assistant', 'üéâ **Card selection appears successful!** The iframe responded to our interaction.');
                    }
                }, 3000);
                
                // Strategy 2: Focus the iframe to ensure it's ready for interaction
                carouselIframe.focus();
                await new Promise(resolve => setTimeout(resolve, 500)); // Wait for iframe to be ready
                
                // Strategy 3: Improved click simulation with multiple attempts
                let clickAttempted = false;
                
                if (cardIndex && typeof cardIndex === 'number') {
                    console.log(`üñ±Ô∏è Attempting to simulate click at position ${cardIndex}`);
                    
                    // Calculate more precise click coordinates
                    const iframeRect = carouselIframe.getBoundingClientRect();
                    
                    // Try multiple click positions for the specified card
                    const cardPositions = [
                        // Position 1: First card (left side)
                        { x: iframeRect.width * 0.2, y: 180 },
                        // Position 2: Second card (center)
                        { x: iframeRect.width * 0.5, y: 180 },
                        // Position 3: Third card (right side)
                        { x: iframeRect.width * 0.8, y: 180 }
                    ];
                    
                    const targetPosition = cardPositions[cardIndex - 1] || cardPositions[0];
                    
                    // Multiple click strategies
                    const clickStrategies = [
                        // Strategy A: Direct iframe click
                        () => {
                            const clickEvent = new MouseEvent('click', {
                                view: window,
                                bubbles: true,
                                cancelable: true,
                                clientX: iframeRect.left + targetPosition.x,
                                clientY: iframeRect.top + targetPosition.y
                            });
                            carouselIframe.dispatchEvent(clickEvent);
                        },
                        
                        // Strategy B: Pointer events
                        () => {
                            const pointerDown = new PointerEvent('pointerdown', {
                                pointerId: 1,
                                bubbles: true,
                                clientX: iframeRect.left + targetPosition.x,
                                clientY: iframeRect.top + targetPosition.y
                            });
                            const pointerUp = new PointerEvent('pointerup', {
                                pointerId: 1,
                                bubbles: true,
                                clientX: iframeRect.left + targetPosition.x,
                                clientY: iframeRect.top + targetPosition.y
                            });
                            carouselIframe.dispatchEvent(pointerDown);
                            setTimeout(() => carouselIframe.dispatchEvent(pointerUp), 50);
                        },
                        
                        // Strategy C: Touch events (for mobile compatibility)
                        () => {
                            try {
                                const touch = new Touch({
                                    identifier: 1,
                                    target: carouselIframe,
                                    clientX: iframeRect.left + targetPosition.x,
                                    clientY: iframeRect.top + targetPosition.y
                                });
                                
                                const touchStart = new TouchEvent('touchstart', {
                                    bubbles: true,
                                    touches: [touch]
                                });
                                const touchEnd = new TouchEvent('touchend', {
                                    bubbles: true,
                                    changedTouches: [touch]
                                });
                                carouselIframe.dispatchEvent(touchStart);
                                setTimeout(() => carouselIframe.dispatchEvent(touchEnd), 50);
                            } catch (touchError) {
                                // Fallback to basic click if touch events fail
                                const clickEvent = new MouseEvent('click', {
                                    bubbles: true,
                                    clientX: iframeRect.left + targetPosition.x,
                                    clientY: iframeRect.top + targetPosition.y
                                });
                                carouselIframe.dispatchEvent(clickEvent);
                            }
                        }
                    ];
                    
                    // Execute all click strategies with delays
                    for (let i = 0; i < clickStrategies.length; i++) {
                        setTimeout(() => {
                            try {
                                clickStrategies[i]();
                                console.log(`üñ±Ô∏è Executed click strategy ${i + 1} at position ${cardIndex}`);
                            } catch (err) {
                                console.log(`‚ö†Ô∏è Click strategy ${i + 1} failed:`, err);
                            }
                        }, i * 200);
                    }
                    
                    clickAttempted = true;
                    addMessage('system', `üñ±Ô∏è Multiple click strategies attempted for position ${cardIndex}`);
                }
                
                // Strategy 4: Try keyboard navigation if no specific position
                if (!clickAttempted) {
                    console.log('üéØ Attempting keyboard navigation approach');
                    
                    // Try to navigate with arrow keys and Enter
                    const keyEvents = ['ArrowRight', 'ArrowRight', 'Enter'];
                    
                    if (cardIndex === 1) keyEvents.splice(0, 2); // First card - just Enter
                    if (cardIndex === 2) keyEvents.splice(1, 1); // Second card - one right, then Enter
                    // Third card and beyond - multiple rights, then Enter
                    
                    for (let i = 0; i < keyEvents.length; i++) {
                        setTimeout(() => {
                            const keyEvent = new KeyboardEvent('keydown', {
                                key: keyEvents[i],
                                bubbles: true
                            });
                            carouselIframe.dispatchEvent(keyEvent);
                        }, i * 100);
                    }
                    
                    addMessage('system', '‚å®Ô∏è Keyboard navigation attempted');
                }
                
                // Strategy 5: Wait and provide comprehensive feedback
                setTimeout(() => {
                    const iframeRect = carouselIframe.getBoundingClientRect();
                    const cardPositions = [
                        { x: iframeRect.width * 0.2, y: 180 },
                        { x: iframeRect.width * 0.5, y: 180 },
                        { x: iframeRect.width * 0.8, y: 180 }
                    ];
                    const targetPosition = cardPositions[cardIndex - 1] || cardPositions[0];
                    
                    addMessage('assistant', `üéØ **Enhanced card selection attempted!**
                    
**Advanced strategies used:**
‚Ä¢ Event listener for iframe response detection
‚Ä¢ Iframe focusing and readiness wait
‚Ä¢ ${clickAttempted ? `Multiple click strategies at position ${cardIndex}` : 'Keyboard navigation approach'}
‚Ä¢ Pointer, touch, and mouse event simulation
‚Ä¢ Precise coordinate calculation
                    
**Next steps:**
1. **Check if card was selected** - Look for visual changes in the carousel
2. **Manual fallback**: Click the desired card directly if needed
3. **Try different position**: Say *"Select card 1"*, *"Select card 2"*, or *"Select card 3"*
                    
**Debugging info:**
‚Ä¢ Iframe dimensions: ${iframeRect.width}x${iframeRect.height}
‚Ä¢ Card position attempted: ${cardIndex || 'N/A'}
‚Ä¢ Click coordinates: ${clickAttempted ? `${targetPosition.x}, ${targetPosition.y}` : 'N/A'}
‚Ä¢ ${cardType ? `Card type: ${cardType}` : ''}
‚Ä¢ ${cardEnding ? `Card ending: ${cardEnding}` : ''}`);
                }, 1500);
                
            } catch (error) {
                console.error('‚ùå Error in card selection:', error);
                addMessage('assistant', `‚ùå **Card selection failed:** ${error.message}
                
**Alternative approaches:**
1. **Manual Selection**: Click the desired card directly in the carousel
2. **Reload Carousel**: Try *"Show payment options for $${((parameters.amount || 1000) / 100).toFixed(2)}"* again
3. **Different Selection**: Try *"Select card 1"* or *"Select the first payment method"*`);
            }
        }

        async function testLookup() {
            console.log('Testing lookup with SDK:', skipifySDK);
            
            if (!skipifySDK) {
                showResult('lookup', { error: 'Skipify SDK not loaded' });
                addMessage('system', '‚ùå Skipify SDK not loaded');
                return;
            }

            const email = document.getElementById('lookupEmail').value;
            const phone = document.getElementById('lookupPhone').value;
            
            if (!email && !phone) {
                showResult('lookup', { error: 'Please provide either email or phone' });
                addMessage('system', '‚ùå Please provide either email or phone for lookup');
                return;
            }
            
            try {
                addMessage('system', 'üîç Performing Skipify lookup...');
                
                // Use the EXACT SAME simple approach as the working reliable lookup
                const lookupParams = {};
                if (email) lookupParams.email = email;
                if (phone) lookupParams.phone = phone;
                
                console.log('üß™ Using proven reliable approach (same as ‚úÖ Reliable Lookup)...');
                addMessage('system', `üîç Looking up with: ${email ? 'email' : ''}${email && phone ? ' + ' : ''}${phone ? 'phone' : ''}`);
                
                // EXACT SAME reliable approach as testReliableLookup()
                const result = await Promise.race([
                    skipifySDK.lookup(lookupParams),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Lookup timed out after 3 seconds')), 3000))
                ]);
                console.log('‚úÖ Test lookup succeeded with reliable approach:', result);
                
                // Validate the response structure
                if (!result) {
                    throw new Error('Lookup returned null or undefined result');
                }
                
                // Check for error response format
                if (result.error) {
                    throw new Error(`Lookup failed: ${result.error.message || 'Unknown error'}`);
                }
                
                // Store the lookup results
                lookupResults = result;
                skipifySessionId = 'lookup-completed';
                addMessage('system', '‚úÖ Lookup successful! You can now proceed with authentication.');
                
                // Auto-populate the challenge ID if available
                if (result && result.challengeId) {
                    document.getElementById('authChallengeId').value = result.challengeId;
                    addMessage('system', `‚úÖ Challenge ID auto-populated: ${result.challengeId}`);
                }
                
                // Show a nicely formatted result with safe property access
                const formattedResult = {
                    ...result,
                    _formatted: `
                        <strong>‚úÖ Lookup successful!</strong><br><br>
                        <strong>Challenge ID:</strong> ${result.challengeId || 'Not provided'}<br>
                        <strong>Flags:</strong><br>
                        ‚Ä¢ Potential Payment Methods: ${result.flags?.potentialPaymentMethods ? 'Yes' : 'No'}<br>
                        ‚Ä¢ Phone Required: ${result.flags?.phoneRequired ? 'Yes' : 'No'}<br>
                        ‚Ä¢ Partner Provided Phone: ${result.flags?.partnerProvidedPhone ? 'Yes' : 'No'}<br>
                        <strong>Metadata:</strong><br>
                        ‚Ä¢ Masked Email: ${result.metadata?.maskedEmail || 'Not provided'}<br>
                        ‚Ä¢ Masked Phone: ${result.metadata?.maskedPhone || 'Not provided'}<br>
                        <strong>Defaults:</strong><br>
                        ‚Ä¢ Destination: ${result.defaults?.destination || 'Not provided'}<br>
                        ‚Ä¢ Masked Channel: ${result.defaults?.maskedChannel || 'Not provided'}<br>
                        <strong>Raw Response:</strong><br>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    `
                };
                
                showResult('lookup', formattedResult);
                
            } catch (error) {
                console.error('Lookup error:', error);
                console.error('Error type:', typeof error);
                console.error('Error constructor:', error.constructor.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                
                let errorMessage = 'Unknown error occurred';
                
                if (error && typeof error === 'object') {
                    if (error.message) {
                        errorMessage = error.message;
                    } else if (error.error) {
                        errorMessage = error.error;
                    } else {
                        errorMessage = JSON.stringify(error);
                    }
                } else if (typeof error === 'string') {
                    errorMessage = error;
                }
                
                showResult('lookup', { error: errorMessage });
                addMessage('system', `‚ùå Lookup failed: ${errorMessage}`);
            }
        }

        async function testReliableLookup() {
            console.log('üéØ testReliableLookup() function called - PROVEN RELIABLE APPROACH');
            
            if (!skipifySDK) {
                addMessage('system', '‚ùå Skipify SDK not loaded');
                return;
            }

            const email = document.getElementById('lookupEmail').value;
            const phone = document.getElementById('lookupPhone').value;
            
            if (!email && !phone) {
                addMessage('system', '‚ùå Please provide either email or phone for lookup');
                return;
            }

            try {
                addMessage('system', 'üîÑ Using proven reliable lookup approach...');
                
                // Build lookup params
                const lookupParams = {};
                if (email) lookupParams.email = email;
                if (phone) lookupParams.phone = phone;
                
                // EXACT SAME reliable approach as simple-fallback.html
                console.log('üß™ Using reliable lookup with 3-second timeout...');
                const result = await Promise.race([
                    skipifySDK.lookup(lookupParams),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Lookup timed out after 3 seconds')), 3000))
                ]);
                
                console.log('‚úÖ Reliable lookup completed successfully:', result);
                
                // Store results for auth testing
                lookupResults = result;
                skipifySessionId = 'lookup-completed';
                addMessage('system', '‚úÖ Reliable lookup successful! You can now proceed with authentication.');
                
                // Auto-populate the challenge ID if available
                if (result && result.challengeId) {
                    document.getElementById('authChallengeId').value = result.challengeId;
                    addMessage('system', `‚úÖ Challenge ID auto-populated: ${result.challengeId}`);
                }
                
                // Show formatted result
                const formattedResult = {
                    ...result,
                    _formatted: `
                        <strong>‚úÖ Reliable lookup successful!</strong><br><br>
                        <strong>Challenge ID:</strong> ${result.challengeId || 'Not provided'}<br>
                        <strong>üìù Raw Response:</strong><br>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                        <br><strong>‚úÖ This uses the same proven code that works reliably!</strong>
                    `
                };
                
                showResult('lookup', formattedResult);
                
            } catch (error) {
                console.error('‚ùå Reliable lookup error:', error);
                addMessage('system', `‚ùå Reliable lookup failed: ${error.message}`);
                showResult('lookup', { error: error.message });
            }
        }

        async function testAuth() {
            if (!skipifySDK) {
                showResult('auth', { error: 'Skipify SDK not loaded' });
                return;
            }

            if (!skipifySessionId || !lookupResults) {
                showResult('auth', { error: 'Please perform a lookup first to get lookup results' });
                return;
            }
            
            const phone = document.getElementById('authPhone').value;
            
            try {
                addMessage('system', 'üîê Performing Skipify authentication...');
                
                // Start the SDK if not already started
                if (typeof skipifySDK.start === 'function') {
                    skipifySDK.start();
                    addMessage('system', 'üöÄ SDK started for authentication');
                }
                
                // Use the stored lookup results and add phone if provided
                const authParams = { ...lookupResults };
                if (phone) {
                    authParams.phone = phone;
                }
                
                console.log('Authentication params:', authParams);
                
                // Call authentication with the lookup results
                const result = await skipifySDK.authentication(authParams, {
                    onSuccess: (data) => {
                        console.log('Authentication success:', data);
                        // Store authentication result for carousel use
                        window.authenticationResult = data;
                        addMessage('system', '‚úÖ Authentication completed successfully - ready for carousel');
                        showResult('auth', { success: true, data: data });
                    },
                    onError: (error) => {
                        console.error('Authentication error:', error);
                        addMessage('system', `‚ùå Authentication failed: ${error.message || error}`);
                        showResult('auth', { error: error.message || error });
                    },
                    onCancel: () => {
                        console.log('Authentication cancelled');
                        addMessage('system', '‚ö†Ô∏è Authentication was cancelled');
                        showResult('auth', { cancelled: true });
                    }
                });
                
                console.log('Authentication result:', result);
                
                // Check if the result contains a render function
                if (result && typeof result.render === 'function') {
                    addMessage('system', 'üé® Calling render function to display authentication component');
                    
                    // Show the auth container
                    const authContainer = document.getElementById('skipify-auth-container');
                    const authContent = document.getElementById('skipify-auth-content');
                    if (authContainer) {
                        authContainer.style.display = 'block';
                        addMessage('system', 'üì± Showing authentication container');
                    }
                    
                    // Call the render function with the auth content container
                    try {
                        const renderResult = result.render(authContent);
                        console.log('Render result:', renderResult);
                        addMessage('system', '‚úÖ Render function called successfully');
                        
                        showResult('auth', { 
                            info: 'Authentication component rendered successfully', 
                            renderResult: renderResult,
                            note: 'Check the authentication container for the OTP input field'
                        });
                        
                    } catch (renderError) {
                        console.error('Render error:', renderError);
                        addMessage('system', `‚ùå Render function failed: ${renderError.message}`);
                        showResult('auth', { error: `Render function failed: ${renderError.message}` });
                    }
                } else {
                    addMessage('system', `‚ÑπÔ∏è Authentication result: ${JSON.stringify(result)}`);
                    showResult('auth', { 
                        info: 'Authentication completed', 
                        result: result
                    });
                }
                
            } catch (error) {
                console.error('Auth error:', error);
                const errorMessage = error.message || error.toString() || 'Unknown error occurred';
                showResult('auth', { error: errorMessage });
                addMessage('system', `‚ùå Authentication failed: ${errorMessage}`);
            }
        }

        async function testCarousel() {
            if (!skipifySDK) {
                showResult('carousel', { error: 'Skipify SDK not loaded' });
                addMessage('system', '‚ùå Skipify SDK not loaded');
                return;
            }

            // Check if we have authentication results (required for carousel)
            if (!window.authenticationResult) {
                showResult('carousel', { error: 'Please complete authentication first to get authenticationResult' });
                addMessage('system', '‚ùå Authentication required first. Please run lookup and authentication before carousel.');
                return;
            }
            
            const amount = parseInt(document.getElementById('carouselAmount').value);
            
            try {
                addMessage('system', 'üí≥ Rendering Skipify payment carousel...');
                console.log('Using authenticationResult for carousel:', window.authenticationResult);
                
                // Create options object as per documentation
                const options = {
                    onSelect: (result) => {
                        console.log('Carousel payment selected:', result);
                        addMessage('system', '‚úÖ Payment method selected successfully');
                        showResult('carousel', { 
                            success: true, 
                            selectedPayment: result,
                            message: 'Payment method selected successfully'
                        });
                    },
                    onError: (error) => {
                        console.error('Carousel error:', error);
                        addMessage('system', `‚ùå Carousel error: ${error.message || error}`);
                        showResult('carousel', { error: error.message || error });
                    },
                    amount: amount, // Amount in cents
                    config: {
                        theme: "light",
                        fontFamily: "default",
                        fontSize: "medium"
                    }
                };
                
                console.log('Carousel options:', options);
                addMessage('system', `üí≥ Rendering carousel with amount: $${(amount/100).toFixed(2)}`);
                
                // Get or create container for carousel - position it right below the Test Carousel button
                let carouselContainer = document.getElementById('carousel-container');
                if (!carouselContainer) {
                    carouselContainer = document.createElement('div');
                    carouselContainer.id = 'carousel-container';
                    carouselContainer.style.margin = '20px 0';
                    carouselContainer.style.padding = '20px';
                    carouselContainer.style.border = '2px solid #28a745';
                    carouselContainer.style.borderRadius = '10px';
                    carouselContainer.style.backgroundColor = '#f8f9fa';
                    
                    // Insert in the placeholder right below the Test Carousel button
                    const placeholder = document.getElementById('carousel-container-placeholder');
                    if (placeholder) {
                        placeholder.appendChild(carouselContainer);
                    } else {
                        // Fallback: insert after the result display if placeholder not found
                        const resultDisplay = document.getElementById('resultDisplay');
                        resultDisplay.parentNode.insertBefore(carouselContainer, resultDisplay.nextSibling);
                    }
                    
                    const header = document.createElement('h4');
                    header.textContent = 'üí≥ Payment Carousel';
                    carouselContainer.appendChild(header);
                }
                
                // Clear previous carousel content
                const existingCarousel = carouselContainer.querySelector('#carousel-content');
                if (existingCarousel) {
                    existingCarousel.remove();
                }
                
                const carouselContent = document.createElement('div');
                carouselContent.id = 'carousel-content';
                carouselContainer.appendChild(carouselContent);
                
                // Use correct API as per documentation: carousel(authenticationResult, options).render(container)
                console.log('Calling skipifySDK.carousel with authenticationResult and options...');
                const carouselComponent = skipifySDK.carousel(window.authenticationResult, options);
                console.log('Carousel component created:', carouselComponent);
                
                // Render the carousel
                console.log('Rendering carousel to container...');
                carouselComponent.render(carouselContent);
                
                addMessage('system', '‚úÖ Carousel component rendered successfully');
                console.log('‚úÖ Carousel rendered successfully');
                
            } catch (error) {
                console.error('Carousel error:', error);
                const errorMessage = error.message || error.toString() || 'Unknown error occurred';
                showResult('carousel', { error: errorMessage });
                addMessage('system', `‚ùå Carousel failed: ${errorMessage}`);
            }
        }

        async function testDeviceId() {
            if (!skipifySDK) {
                showResult('device-id', { error: 'Skipify SDK not loaded' });
                return;
            }

            try {
                addMessage('system', 'üì± Getting device ID...');
                
                // Ensure SDK is started before performing operations
                if (typeof skipifySDK.start === 'function') {
                    console.log('Starting Skipify SDK for device ID...');
                    skipifySDK.start();
                    addMessage('system', 'üîÑ SDK started for device ID...');
                    // Wait for SDK to be fully ready
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                // Use the correct method name: getDeviceId
                // The SDK manages the session internally, so we don't need to pass sessionId
                const result = await skipifySDK.getDeviceId();
                
                showResult('device-id', result);
                addMessage('system', '‚úÖ Device ID retrieved');
                
            } catch (error) {
                console.error('Device ID error:', error);
                const errorMessage = error.message || error.toString() || 'Unknown error occurred';
                showResult('device-id', { error: errorMessage });
                addMessage('system', `‚ùå Device ID failed: ${errorMessage}`);
            }
        }

        function showResult(operation, data) {
            const resultDisplay = document.getElementById('resultDisplay');
            const resultContent = document.getElementById('resultContent');
            
            resultContent.className = data.error ? 'error' : 'success';
            resultContent.innerHTML = `
                <strong>Operation:</strong> ${operation}<br>
                <strong>Timestamp:</strong> ${new Date().toLocaleString()}<br>
                <strong>Session ID:</strong> ${skipifySessionId || 'None'}<br>
                <strong>Result:</strong><br>
                <pre>${JSON.stringify(data, null, 2)}</pre>
            `;
            
            resultDisplay.style.display = 'block';
        }

        function debugSDK() {
            if (!skipifySDK) {
                addMessage('system', '‚ùå Skipify SDK not loaded. Please ensure the CDN script is included.');
                return;
            }

            const debugInfo = `
                <h4>üîç Skipify SDK Debug Information</h4>
                <p><strong>SDK Constructor:</strong> ${skipifySDK.constructor.name}</p>
                <p><strong>SDK Prototype Methods:</strong> ${Object.getOwnPropertyNames(Object.getPrototypeOf(skipifySDK)).join(', ')}</p>
                <p><strong>SDK Instance Properties:</strong> ${Object.keys(skipifySDK).join(', ')}</p>
                <p><strong>SDK Start Method:</strong> ${typeof skipifySDK.start === 'function' ? 'Yes' : 'No'}</p>
                <p><strong>SDK Lookup Method:</strong> ${typeof skipifySDK.lookup === 'function' ? 'Yes' : 'No'}</p>
                <p><strong>SDK Authentication Method:</strong> ${typeof skipifySDK.authentication === 'function' ? 'Yes' : 'No'}</p>
                <p><strong>SDK Carousel Method:</strong> ${typeof skipifySDK.carousel === 'function' ? 'Yes' : 'No'}</p>
                <p><strong>SDK Get Device ID Method:</strong> ${typeof skipifySDK.getDeviceId === 'function' ? 'Yes' : 'No'}</p>
            `;
            addMessage('system', debugInfo);
        }

        // Network monitoring function
        function startNetworkMonitoring() {
            console.log('Starting network monitoring...');
            
            // Monitor fetch requests
            const originalFetch = window.fetch;
            let fetchCount = 0;
            let fetchRequests = [];
            
            window.fetch = function(...args) {
                fetchCount++;
                const request = {
                    id: fetchCount,
                    url: args[0],
                    options: args[1],
                    timestamp: new Date().toISOString()
                };
                fetchRequests.push(request);
                console.log('Fetch request detected:', request);
                
                return originalFetch.apply(this, args).then(response => {
                    console.log('Fetch response received:', response);
                    return response;
                }).catch(error => {
                    console.error('Fetch error:', error);
                    throw error;
                });
            };
            
            // Monitor XMLHttpRequest
            const originalXHROpen = XMLHttpRequest.prototype.open;
            const originalXHRSend = XMLHttpRequest.prototype.send;
            let xhrCount = 0;
            let xhrRequests = [];
            
            XMLHttpRequest.prototype.open = function(method, url, ...args) {
                xhrCount++;
                this._requestId = xhrCount;
                this._requestUrl = url;
                this._requestMethod = method;
                this._requestTimestamp = new Date().toISOString();
                
                const request = {
                    id: xhrCount,
                    method: method,
                    url: url,
                    timestamp: this._requestTimestamp
                };
                xhrRequests.push(request);
                console.log('XHR request detected:', request);
                
                return originalXHROpen.apply(this, [method, url, ...args]);
            };
            
            XMLHttpRequest.prototype.send = function(data) {
                console.log('XHR send called for request:', this._requestId, 'with data:', data);
                return originalXHRSend.apply(this, [data]);
            };
            
            console.log('Network monitoring active');
            addMessage('system', 'üì° Network monitoring started - will track all requests during lookup');
            
            // Return function to get monitoring results
            return function() {
                const totalRequests = fetchRequests.length + xhrRequests.length;
                const summary = `
                    <strong>Network Monitoring Summary:</strong><br>
                    Fetch requests: ${fetchRequests.length}<br>
                    XHR requests: ${xhrRequests.length}<br>
                    Total requests: ${totalRequests}<br><br>
                    <strong>Fetch Requests:</strong><br>
                    ${fetchRequests.map(req => `${req.id}: ${req.url}`).join('<br>')}<br><br>
                    <strong>XHR Requests:</strong><br>
                    ${xhrRequests.map(req => `${req.id}: ${req.method} ${req.url}`).join('<br>')}
                `;
                addMessage('system', summary);
                return { fetchRequests, xhrRequests, totalRequests };
            };
        }
    </script>
</body>
</html>